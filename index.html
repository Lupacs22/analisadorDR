<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gerador de Setor de 22,5º e raio 4 km</title>
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa4b2; --panel:#1f2937; --border:#233147; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;background:var(--bg);color:var(--fg);overflow-x:hidden}

  header{padding:12px 16px;border-bottom:1px solid #1e2533;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:16px;margin:0;color:#eaf2ff}

  .wrap{display:grid;grid-template-columns:400px 1fr;gap:12px;height:calc(100vh - 60px)}
  .left{padding:12px;border-right:1px solid #1e2533;overflow-y:auto;overflow-x:hidden}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px;margin-bottom:12px}
  .panel h2{font-size:14px;margin:0 0 8px;color:#cfe1ff}
  label{font-size:12px;color:#cfd8f5}

  input[type="file"],button,input[type="number"]{
    background:#0b0f16;color:#e6ecff;border:1px solid #233147;border-radius:10px;padding:8px 10px}
  input[type="number"]{width:110px}
  button{background:#101726;border:1px solid #2a3954;cursor:pointer;white-space:nowrap}
  button:hover{border-color:#3a4f78}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;max-width:100%}
  .small{font-size:12px;color:var(--muted)}
  .sep{height:1px;background:#1b2230;margin:8px 0}

  #sectorList .item{display:flex; align-items:center; gap:8px;padding:6px; border:1px solid #2a3954; border-radius:10px; margin-bottom:8px;background:#0b0f16;}
  #sectorList .idx{width:36px;text-align:center;color:#cfe1ff;font-weight:600}
  #sectorList .label{font-size:12px;color:#b9c3da}
  #sectorList .grow{flex:1 1 auto}
  #sectorList .controls{display:flex; gap:6px; flex-wrap:wrap}

  #measureList .item{display:flex; align-items:center; gap:8px;padding:6px; border:1px solid #2a3954; border-radius:10px; margin-bottom:8px; background:#0b0f16;}
  #measureList .idx{width:36px;text-align:center;color:#cfe1ff;font-weight:600}
  #measureList .val{font-size:12px;color:#b9c3da}
  #measureList .grow{flex:1 1 auto}

  #stage{position:relative;background:#0a0d14;height:100%;overflow:auto}
  #content{position:relative}
  #layer-pdf,#layer-overlay{position:absolute;left:0;top:0;width:100%;height:100%}
  #pdfCanvas{display:block;width:100%;height:100%;background:#11151f}
  #overlay{display:block;width:100%;height:100%;cursor:grab}
  #overlay.grabbing{cursor:grabbing}
  #overlay.cursor-xhair{cursor:crosshair !important}

  #log{white-space:pre-wrap; overflow-wrap:anywhere}
</style>
</head>
<body>
<header>
  <h1>Gerador de Setor de 22,5º e raio 4 km</h1>
</header>

<div class="wrap">
  <div class="left">
    <div class="panel">
      <h2>Arquivo</h2>
      <div class="row">
        <input id="file" type="file" accept="application/pdf">
        <button id="resetAll">Reset</button>
        <button id="downloadImg">Baixar Imagem</button>
      </div>
    </div>

    <div class="panel">
      <h2>Calibração</h2>
      <div class="row">
        <button id="btnCalibDist">Calibrar por distância</button>
        <span class="small">Clique 2 pontos e informe a distância real (km).</span>
      </div>
      <div class="sep"></div>
      <div class="small">Escala: <span id="scaleStatus">não definida</span></div>
    </div>

    <div class="panel">
      <h2>Círculo de Raio de 4 km</h2>
      <div class="row">
        <button id="btnAnchor">Definir centro</button>
        <button id="clearCircle">Limpar círculo</button>
      </div>
      <div class="small">Define/limpa um círculo de referência (azul tracejado) em 4 km.</div>
    </div>

    <div class="panel">
      <h2>Setor de 22,5° e raio de 4 km</h2>
      <div class="row">
        <button id="btnInsert225">Inserir</button>
        <button id="btnStopProbe">Parar passeio</button>
        <button id="btnClear225">Limpar setores</button>
      </div>
      <div class="sep"></div>
      <div class="small">Setores inseridos:</div>
      <div id="sectorList"></div>
    </div>

    <div class="panel">
      <h2>Régua</h2>
      <div class="row">
        <button id="btnMeasure">Medir distância</button>
        <button id="btnClearMeasure">Limpar medidas</button>
      </div>
      <div class="small">Clique em dois pontos para medir. Use a rolagem para zoom e arraste para mover.</div>
      <div id="measureList" style="margin-top:8px;"></div>
    </div>

    <div class="panel">
      <h2>Zoom & Navegação</h2>
      <div class="row">
        <button id="zoomOut">Zoom −</button>
        <button id="zoomIn">Zoom +</button>
        <button id="zoomReset">Reset</button>
      </div>
    </div>

    <div class="panel">
      <h2>Log</h2>
      <pre id="log" class="small">- Pronto.</pre>
    </div>
  </div>

  <div id="stage">
    <div id="content" style="width:1200px;height:800px">
      <div id="layer-pdf"><canvas id="pdfCanvas" width="1200" height="800"></canvas></div>
      <div id="layer-overlay"><canvas id="overlay" width="1200" height="800"></canvas></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
/* ===== util ===== */
const $ = s => document.querySelector(s);
const logEl = $('#log');
function adjustLogScroll(){ const lines = logEl.textContent.split('\n').length; if (lines > 10){ logEl.style.maxHeight = '220px'; logEl.style.overflowY = 'auto'; } else { logEl.style.maxHeight=''; logEl.style.overflowY=''; } logEl.scrollTop = logEl.scrollHeight; }
function log(m){ logEl.textContent += '\n- ' + m; adjustLogScroll(); }
function toRad(d){return d*Math.PI/180} function toDeg(r){return r*180/Math.PI}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function normAz(d){ return ((d%360)+360)%360; }
function shortAngleDiff(a,b){ let d = (a-b+540)%360 - 180; return d; }
function formatAzLabel(deg){ let n = Math.round(normAz(deg)); if (n===0) n=360; return String(n).padStart(3,'0'); }

/* ===== camadas ===== */
const stage = $('#stage');
const content = $('#content');
const pdfCanvas = $('#pdfCanvas');
const pdfCtx = pdfCanvas.getContext('2d'); // render direto, como no exemplo
const overlay = $('#overlay'); const ctx = overlay.getContext('2d');

/* ===== base + zoom (HiDPI) ===== */
let baseW=1200, baseH=800, scale=1;
function setBaseSize(w,h){ baseW=Math.max(1,Math.floor(w)); baseH=Math.max(1,Math.floor(h)); applyScale(true); }
function applyScale(resetScroll=false){
  const dpr = window.devicePixelRatio || 1;
  const Wcss = Math.round(baseW*scale), Hcss = Math.round(baseH*scale);

  // dimensiona área visível
  content.style.width = Wcss+'px'; content.style.height = Hcss+'px';

  // ajusta buffers HiDPI
  overlay.width = Math.round(Wcss*dpr); overlay.height = Math.round(Hcss*dpr);
  pdfCanvas.width = Math.round(Wcss*dpr); pdfCanvas.height = Math.round(Hcss*dpr);

  // limpa overlay e re-renderiza PDF na escala atual (SEM escurecer)
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  renderPdfAtScale(scale, dpr); // <<< igual ao recurso do seu outro projeto
  redrawAll();

  if (resetScroll){ stage.scrollLeft=0; stage.scrollTop=0; }
}
$('#zoomIn').onclick  = ()=> zoomAtCenter(1.2);
$('#zoomOut').onclick = ()=> zoomAtCenter(1/1.2);
$('#zoomReset').onclick=()=>{ scale = 1; applyScale(true); };

stage.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const factor = (e.deltaY < 0) ? 1.12 : 1/1.12;
  zoomAtCursor(e.clientX, e.clientY, factor);
}, {passive:false});

function zoomAtCenter(factor){
  const rect = stage.getBoundingClientRect();
  zoomAtCursor(rect.left + rect.width/2, rect.top + rect.height/2, factor);
}
function zoomAtCursor(clientX, clientY, factor){
  const old = scale;
  const ns = clamp(scale * factor, 0.15, 16);
  if (ns === old) return;
  const sRect = stage.getBoundingClientRect();
  const pxDisp = stage.scrollLeft + (clientX - sRect.left);
  const pyDisp = stage.scrollTop  + (clientY - sRect.top);
  const baseX = pxDisp / old;
  const baseY = pyDisp / old;
  scale = ns; applyScale(false);
  const newPx = baseX * ns, newPy = baseY * ns;
  stage.scrollLeft = Math.max(0, newPx - (clientX - sRect.left));
  stage.scrollTop  = Math.max(0, newPy - (clientY - sRect.top));
}

/* ===== pan ===== */
let isPanning=false, panStart=null, scrollStart=null, suppressClick=false;
overlay.addEventListener('mousedown', (e)=>{
  if (e.button!==0) return;
  if (mode && mode!=='probeMove') return;
  isPanning=false;
  panStart = {x:e.clientX, y:e.clientY};
  scrollStart = {x:stage.scrollLeft, y:stage.scrollTop};
  overlay.classList.add('grabbing');
  const onMove = (ev)=>{
    const dx = ev.clientX - panStart.x, dy = ev.clientY - panStart.y;
    if (!isPanning && Math.hypot(dx,dy) > 3) isPanning=true;
    if (isPanning){ stage.scrollLeft = scrollStart.x - dx; stage.scrollTop = scrollStart.y - dy; }
  };
  const onUp = ()=>{
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
    overlay.classList.remove('grabbing');
    if (isPanning){ suppressClick = true; setTimeout(()=> suppressClick=false, 80); }
  };
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
});

/* ===== estados ===== */
const FIXED_RADIUS_KM = 4;
const SECTOR90_ALPHA = 0.10;
const PROBE_ALPHA    = 0.30;
const CIRCLE_COLOR = 'rgb(0,1,255)';
const MEASURE_COLOR      = 'rgba(0, 70, 160, 0.95)';
const MEASURE_PREVIEW    = 'rgba(0, 70, 160, 0.55)';
const PROBE_FILL = `rgba(0, 255, 0, ${PROBE_ALPHA})`;
const PROBE_EDGE = 'rgba(0,128,0,0.9)';

let mode=null; // 'calibDist' | 'anchor' | 'insert225' | 'measure' | 'probeMove'
let tempPtsBase=[]; let metersPerBasePx=null;
let anchorBase=null; let showCircle=false;

let sectors225 = []; // {bisAz, probeAz}
let measures = [];   // {a:{x,y}, b:{x,y}}
let measureTemp = null;
let lastMouseDisp = null;
let activeProbeIndex = -1;

/* ===== PDF.js ===== */
let currentPdfBuffer = null;
let pdfDoc = null;
let pdfPage = null;
let renderTask = null;

async function loadPdfFromArrayBuffer(buf){
  if (!window['pdfjsLib']){ log('PDF.js não disponível.'); return; }
  if (!pdfjsLib.GlobalWorkerOptions.workerSrc){
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  }
  pdfDoc = await pdfjsLib.getDocument({data: buf}).promise;
  pdfPage = await pdfDoc.getPage(1);
  const viewportBase = pdfPage.getViewport({scale:1});
  setBaseSize(viewportBase.width, viewportBase.height);
  await renderPdfAtScale(scale, window.devicePixelRatio||1);
  log('PDF carregado e renderizado.');
}

async function renderPdfAtScale(s=1, dpr=1){
  const ctx2d = pdfCtx;
  ctx2d.setTransform(1,0,0,1,0,0);
  ctx2d.fillStyle='#11151f'; ctx2d.fillRect(0,0,pdfCanvas.width,pdfCanvas.height);
  if (!pdfPage) return;
  if (renderTask && renderTask.cancel) { try{ renderTask.cancel(); }catch{} }
  const viewport = pdfPage.getViewport({scale: s * dpr});
  renderTask = pdfPage.render({canvasContext: ctx2d, viewport});
  try{ await renderTask.promise; }catch(e){ /* cancelado */ }
}

/* ===== arquivo ===== */
$('#resetAll').onclick = ()=>{
  const ok = confirm('Deseja realmente resetar? Isso removerá o PDF e todos os desenhos.');
  if (!ok){ log('Reset cancelado.'); return; }
  hardReset();
};

function hardReset(){
  mode = null; activeProbeIndex = -1;
  overlay.classList.remove('cursor-xhair','grabbing');

  if (renderTask && typeof renderTask.cancel === 'function') { try { renderTask.cancel(); } catch(e) {} renderTask=null; }
  currentPdfBuffer=null; pdfDoc=null; pdfPage=null;

  logEl.textContent = '- Página resetada.'; adjustLogScroll();

  $('#file').value = '';
  const dpr = window.devicePixelRatio||1;

  baseW=1200; baseH=800; scale=1;
  content.style.width = baseW+'px'; content.style.height = baseH+'px';
  stage.scrollLeft=0; stage.scrollTop=0;

  pdfCanvas.width = Math.round(baseW*dpr); pdfCanvas.height = Math.round(baseH*dpr);
  pdfCtx.setTransform(1,0,0,1,0,0);
  pdfCtx.fillStyle='#11151f'; pdfCtx.fillRect(0,0,pdfCanvas.width,pdfCanvas.height);

  overlay.width = Math.round(baseW*dpr); overlay.height = Math.round(baseH*dpr);
  ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,overlay.width,overlay.height); ctx.setTransform(dpr,0,0,dpr,0,0);

  sectors225 = []; measures=[]; measureTemp=null; lastMouseDisp=null;
  metersPerBasePx=null; tempPtsBase=[];
  anchorBase=null; showCircle=false;
  updateScaleStatus();
  renderSectorList(); renderMeasureList();
}

$('#file').addEventListener('change', async e=>{
  const f=e.target.files?.[0]; if(!f) return;
  const isPdf = (f.type==='application/pdf') || ((f.name.split('.').pop()||'').toLowerCase()==='pdf');
  if (!isPdf){ alert('Apenas arquivos PDF são permitidos.'); $('#file').value=''; return; }
  currentPdfBuffer = await f.arrayBuffer().catch(()=>null);
  if (!currentPdfBuffer){ log('Falha ao ler o arquivo.'); return; }
  try{ await loadPdfFromArrayBuffer(currentPdfBuffer); }
  catch(err){ log('Erro ao abrir o PDF.'); console.error(err); }
  resetCalcs();
});

/* ===== helpers ===== */
function updateScaleStatus(){ $('#scaleStatus').textContent = metersPerBasePx ? 'definida' : 'não definida'; }
function requireScaleOrAlert(){ if (!metersPerBasePx){ alert('Defina a escala por distância primeiro.'); return false;} return true; }

/* ===== calibração & círculo ===== */
$('#btnCalibDist').onclick = ()=>{ mode='calibDist'; tempPtsBase=[]; overlay.classList.add('cursor-xhair'); log('Calibrar por distância: clique 2 pontos e informe a distância real (km).'); };
$('#btnAnchor').onclick = ()=>{ if (!requireScaleOrAlert()) return; mode='anchor'; overlay.classList.add('cursor-xhair'); log('Clique para definir o centro do círculo (4 km).'); };
$('#clearCircle').onclick = ()=>{ anchorBase=null; showCircle=false; redrawAll(); log('Círculo removido.'); };

/* ===== eventos overlay ===== */
overlay.addEventListener('mousemove', (e)=>{
  lastMouseDisp = pointerDisplay(e);

  // passeio 22,5° com rótulos só nas bordas
  if (mode==='probeMove' && activeProbeIndex>=0 && sectors225[activeProbeIndex] && anchorBase){
    const pBase = dispToBase(lastMouseDisp);
    const dx = pBase.x - anchorBase.x;
    const dy = pBase.y - anchorBase.y;
    const rawAz = normAz(toDeg(Math.atan2(dy, dx) + Math.PI/2)); // 0=N
    const s = sectors225[activeProbeIndex];
    const maxOffset = 45 - 11.25; // 33.75
    let delta = shortAngleDiff(rawAz, s.bisAz);
    delta = clamp(delta, -maxOffset, maxOffset);
    s.probeAz = normAz(s.bisAz + delta);
    redrawAll(); // atualiza labels
  }

  if (mode==='measure' && measureTemp){ redrawAll(); }
});

overlay.addEventListener('click', (e)=>{
  if (suppressClick) return;
  const pDisp = pointerDisplay(e); const pBase = dispToBase(pDisp);

  if (mode==='probeMove'){ stopProbe(); log('Passeio 22,5° finalizado.'); return; }

  if (mode==='calibDist'){
    tempPtsBase.push([pBase.x,pBase.y]); drawMark(pDisp.x,pDisp.y);
    if (tempPtsBase.length===2){
      const km = Number(prompt('Distância real entre os pontos (km):','3'));
      if(!km||km<=0){ log('Calibração cancelada.'); tempPtsBase=[]; overlay.classList.remove('cursor-xhair'); redrawAll(); return; }
      const [a,b]=tempPtsBase; const dBase = Math.hypot(b[0]-a[0], b[1]-a[1]);
      metersPerBasePx = (km*1000)/dBase;
      log('Calibração concluída.');
      updateScaleStatus();
      tempPtsBase=[]; mode=null; overlay.classList.remove('cursor-xhair'); redrawAll();
    }
    return;
  }

  if (mode==='anchor'){
    anchorBase = {x:pBase.x, y:pBase.y};
    showCircle = true;
    mode=null; overlay.classList.remove('cursor-xhair');
    redrawAll();
    log('Centro do círculo definido.');
    return;
  }

  if (mode==='insert225'){
    if (!requireScaleOrAlert()) { mode=null; overlay.classList.remove('cursor-xhair'); return; }
    if (!anchorBase){ alert('Defina primeiro o centro do círculo.'); mode=null; overlay.classList.remove('cursor-xhair'); return; }

    const dx = pBase.x - anchorBase.x;
    const dy = pBase.y - anchorBase.y;
    const bisAzFloat = normAz(toDeg(Math.atan2(dy, dx) + Math.PI/2));
    const bisAz = Math.round(bisAzFloat); // inteiro

    sectors225.push({bisAz, probeAz: bisAz});
    log(`Setor 90° inserido (bissetriz ${bisAz}).`);
    renderSectorList();
    mode=null; overlay.classList.remove('cursor-xhair');
    redrawAll();
    return;
  }

  if (mode==='measure'){
    if (!requireScaleOrAlert()) { mode=null; overlay.classList.remove('cursor-xhair'); return; }
    if (!measureTemp){
      measureTemp = {x:pBase.x, y:pBase.y};
      log('Primeiro ponto da régua definido.');
    } else {
      measures.push({ a:{...measureTemp}, b:{x:pBase.x, y:pBase.y} });
      const km = lengthKm(measureTemp, pBase);
      log(`Medida inserida: ${formatDist(km)}.`);
      measureTemp = null;
      mode=null; overlay.classList.remove('cursor-xhair');
      renderMeasureList();
    }
    redrawAll();
    return;
  }
});

/* ===== Setor 22,5° ===== */
$('#btnInsert225').onclick = ()=>{ if (!requireScaleOrAlert()) return; if (!anchorBase){ alert('Defina primeiro o centro do círculo.'); return; } mode='insert225'; overlay.classList.add('cursor-xhair'); log('Clique no mapa para orientar a bissetriz do setor 90°.'); };
$('#btnClear225').onclick = ()=>{ sectors225 = []; activeProbeIndex=-1; renderSectorList(); redrawAll(); log('Todos os setores removidos.'); };
$('#btnStopProbe').onclick = ()=>{ if (mode==='probeMove'){ stopProbe(); log('Passeio 22,5° interrompido.'); } };

function stopProbe(){ mode = null; activeProbeIndex = -1; overlay.classList.remove('cursor-xhair'); }

function renderSectorList(){
  const list = $('#sectorList');
  list.innerHTML = '';
  sectors225.forEach((s, i)=>{
    const item = document.createElement('div');
    item.className = 'item';

    const idx = document.createElement('div'); idx.className = 'idx'; idx.textContent = i+1;

    const label = document.createElement('div'); label.className = 'label'; label.textContent = 'Bissetriz (°):';

    // edição apenas inteiro
    const inp = document.createElement('input'); 
    inp.type='number'; 
    inp.step='1'; 
    inp.value = String(Math.round(s.bisAz));
    inp.addEventListener('change', ()=>{
      let v = parseInt(inp.value, 10);
      if (Number.isNaN(v)) v = 0;
      v = ((v%360)+360)%360;
      s.bisAz = v;
      s.probeAz = v;
      inp.value = String(v);
      redrawAll();
      log(`Setor ${i+1} atualizado para bissetriz ${v}.`);
    });

    const filler = document.createElement('div'); filler.className='grow';

    const controls = document.createElement('div'); controls.className='controls';

    const btnProbe = document.createElement('button'); btnProbe.textContent='Passear 22,5°';
    btnProbe.addEventListener('click', ()=>{
      if (!anchorBase){ alert('Defina o centro primeiro.'); return; }
      activeProbeIndex = i;
      mode='probeMove';
      overlay.classList.add('cursor-xhair');
      log(`Passeio 22,5° no setor ${i+1}: mova o mouse; clique ou "Parar passeio" para finalizar.`);
    });

    const btnCenter = document.createElement('button'); btnCenter.textContent='Centralizar';
    btnCenter.addEventListener('click', ()=>{
      s.probeAz = s.bisAz; redrawAll();
      log(`Setor ${i+1}: probe 22,5° centralizado na bissetriz.`);
    });

    const del = document.createElement('button'); del.textContent='Excluir';
    del.addEventListener('click', ()=>{
      const rem = sectors225.splice(i,1);
      if (activeProbeIndex===i){ stopProbe(); }
      renderSectorList(); redrawAll();
      if (rem.length) log(`Setor ${i+1} removido.`);
    });

    controls.append(btnProbe, btnCenter, del);
    item.append(idx, label, inp, filler, controls);
    list.appendChild(item);
  });
}

/* ===== Régua ===== */
$('#btnMeasure').onclick = ()=>{ if (!requireScaleOrAlert()) return; mode='measure'; measureTemp=null; overlay.classList.add('cursor-xhair'); log('Régua: clique o primeiro ponto e depois o segundo.'); };
$('#btnClearMeasure').onclick = ()=>{ measures = []; measureTemp=null; renderMeasureList(); redrawAll(); log('Todas as medidas foram removidas.'); };

function renderMeasureList(){
  const list = $('#measureList'); list.innerHTML = '';
  measures.forEach((m, i)=>{
    const km = lengthKm(m.a, m.b);
    const item = document.createElement('div'); item.className = 'item';
    const idx = document.createElement('div'); idx.className='idx'; idx.textContent = i+1;
    const val = document.createElement('div'); val.className='val'; val.textContent = formatDist(km);
    const filler = document.createElement('div'); filler.className='grow';
    const del = document.createElement('button'); del.textContent='Excluir';
    del.addEventListener('click', ()=>{ measures.splice(i,1); renderMeasureList(); redrawAll(); log(`Medida ${i+1} removida.`); });
    item.append(idx, val, filler, del);
    list.appendChild(item);
  });
}

function lengthKm(a, b){ if (!metersPerBasePx) return 0; const dBase = Math.hypot(b.x - a.x, b.y - a.y); const meters = dBase * metersPerBasePx; return meters / 1000; }
function formatDist(km){ if (km >= 1) return `${km.toFixed(2)} km`; return `${Math.round(km*1000)} m`; }

/* ===== download imagem ===== */
$('#downloadImg').onclick = async ()=>{
  const W = overlay.width, H = overlay.height;
  if (!W || !H){ log('Nada para exportar.'); return; }
  const dpr = window.devicePixelRatio || 1;
  const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
  const c = canvas.getContext('2d');
  let rendered = false;
  if (pdfPage){
    try{
      const viewport = pdfPage.getViewport({scale: scale * dpr});
      const tmp = document.createElement('canvas'); tmp.width=viewport.width; tmp.height=viewport.height;
      await pdfPage.render({canvasContext: tmp.getContext('2d'), viewport}).promise;
      c.drawImage(tmp,0,0, W, H);
      rendered = true;
    }catch(err){ log('Falha ao renderizar PDF para exportar (exportando apenas desenhos).'); }
  }else{
    c.fillStyle='#ffffff'; c.fillRect(0,0,W,H);
  }
  c.drawImage(overlay,0,0);
  const url = canvas.toDataURL('image/png');
  const a=document.createElement('a'); a.href=url; a.download='Setor225.png'; a.click();
  log(rendered ? 'Imagem exportada (PDF + desenhos, HiDPI).' : 'Imagem exportada (apenas desenhos, HiDPI).');
};

/* ===== desenho principal ===== */
function redrawAll(){
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,overlay.width,overlay.height);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // pontos temporários (calib)
  tempPtsBase.forEach(([bx,by])=>{ const p=baseToDisp({x:bx,y:by}); drawMark(p.x,p.y); });

  // círculo
  if (showCircle && anchorBase && metersPerBasePx){
    const rpx = radiusPxDisp();
    const a = baseToDisp(anchorBase);
    drawCircleAt(a.x, a.y, rpx, CIRCLE_COLOR);
  }

  // setor 90° + probe 22,5°
  if (metersPerBasePx && anchorBase && sectors225.length){
    const rpx = radiusPxDisp();
    const a = baseToDisp(anchorBase);

    sectors225.forEach(item=>{
      const bis = item.bisAz;
      const start90 = normAz(bis - 45);
      const end90   = normAz(bis + 45);

      // 90° verde 10%
      drawWedgeCustom(a.x, a.y, rpx, start90, end90, `rgba(0,255,0,${SECTOR90_ALPHA})`, 'rgba(0,128,0,0.8)', 1.6);

      // bordas do 90° (sem bissetriz)
      const bounds = [start90, end90];
      const labelOffset = rpx + 12;
      bounds.forEach((d)=>{
        drawRadialLine(a.x, a.y, rpx, d, 'rgba(255,0,0,0.95)', 2.2);
        drawAzLabelAt(a.x, a.y, d, labelOffset, '#000000');
      });

      // PROBE 22,5° (verde 30%)
      const probe = (typeof item.probeAz==='number') ? item.probeAz : bis;
      const probeStart = normAz(probe - 11.25);
      const probeEnd   = normAz(probe + 11.25);
      drawWedgeCustom(a.x, a.y, rpx, probeStart, probeEnd, PROBE_FILL, PROBE_EDGE, 2.2);

      // >>> Rótulos SEMPRE nas BORDAS do setor de passeio (sem HUD da bissetriz)
	{
 	 const lblR = rpx + 12;
  	drawAzLabelAt(a.x, a.y, probeStart, lblR, '#000000');
  	drawAzLabelAt(a.x, a.y, probeEnd,   lblR, '#000000');
	}

    });
  }

  // medidas
  if (metersPerBasePx && measures.length){
    measures.forEach(m=>{ drawMeasureSegment(m.a, m.b); });
  }

  // prévia régua
  if (mode==='measure' && measureTemp && lastMouseDisp){
    const p2 = dispToBase(lastMouseDisp);
    drawMeasureSegment(measureTemp, p2, true);
  }
}

/* ===== primitivos ===== */
function drawCircleAt(cx, cy, r, color){
  ctx.save(); ctx.strokeStyle = color || 'rgb(0,1,255)';
  ctx.lineWidth = 2.6; ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
  ctx.setLineDash([]); ctx.restore();
}
function drawWedgeCustom(cx, cy, r, startDeg, endDeg, fill, edge, edgeW){
  const start = (-Math.PI/2) + toRad(startDeg);
  let end = (-Math.PI/2) + toRad(endDeg);
  let delta = end - start; if (delta <= 0) delta += Math.PI*2;
  const segs = Math.max(12, Math.floor(delta/(Math.PI/72)));
  ctx.save();
  ctx.beginPath(); ctx.moveTo(cx, cy);
  for (let i=0;i<=segs;i++){
    const t = i/segs; const ang = start + t*delta;
    ctx.lineTo(cx + Math.cos(ang)*r, cy + Math.sin(ang)*r);
  }
  ctx.closePath();
  if (fill){ ctx.fillStyle = fill; ctx.fill(); }
  if (edge){ ctx.lineWidth = edgeW||2; ctx.strokeStyle = edge; ctx.stroke(); }
  ctx.restore();
}
function drawRadialLine(cx, cy, r, deg, stroke='rgba(255,0,0,0.95)', lw=2){
  const ang = (-Math.PI/2) + toRad(deg);
  const vx = Math.cos(ang)*r, vy = Math.sin(ang)*r;
  ctx.save(); ctx.strokeStyle = stroke; ctx.lineWidth = lw;
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + vx, cy + vy); ctx.stroke();
  ctx.restore();
}
function drawAzLabelAt(cx, cy, deg, rOut, fillColor='#000000'){
  const ang = (-Math.PI/2) + toRad(deg);
  const x = cx + Math.cos(ang)*rOut;
  const y = cy + Math.sin(ang)*rOut;
  const m = 6; const dx = Math.cos(ang)*m, dy = Math.sin(ang)*m;
  ctx.save();
  ctx.font='bold 18px Arial, Helvetica, sans-serif';
  ctx.textAlign   = (Math.cos(ang) >= 0) ? 'left'  : 'right';
  ctx.textBaseline= (Math.sin(ang) >= 0) ? 'top'   : 'bottom';
  ctx.fillStyle = fillColor;
  const txt = formatAzLabel(deg); // 3 dígitos, sem "°"
  ctx.fillText(txt, x+dx, y+dy);
  ctx.restore();
}

/* === régua === */
function drawMeasureSegment(aBase, bBase, preview=false){
  const a = baseToDisp(aBase), b = baseToDisp(bBase);
  const km = lengthKm(aBase, bBase);
  const mid = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };

  const stroke = preview ? MEASURE_PREVIEW : MEASURE_COLOR;

  ctx.save();
  ctx.lineWidth = 2.4; ctx.strokeStyle = stroke;
  if (preview) ctx.setLineDash([6,6]);

  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  ctx.setLineDash([]);

  const ang = Math.atan2(b.y - a.y, b.x - a.x);
  drawArrowHead(b.x, b.y, ang, 12, stroke);
  drawArrowHead(a.x, a.y, ang + Math.PI, 12, stroke);

  const label = formatDist(km);
  const padX=6, padY=4; ctx.font='bold 14px Arial, Helvetica, sans-serif';
  const tw = ctx.measureText(label).width; const th = 16;

  const vx = b.x-a.x, vy=b.y-a.y; const len = Math.hypot(vx,vy)||1;
  const nx = -vy/len, ny = vx/len; const off = 10;
  const lx = mid.x + nx*off, ly = mid.y + ny*off;

  ctx.fillStyle = preview ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.85)';
  roundRect(ctx, lx - tw/2 - padX, ly - th/2 - padY, tw + 2*padX, th + 2*padY, 6);
  ctx.fill();

  ctx.fillStyle = '#000'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(label, lx, ly);
  ctx.restore();
}

function drawArrowHead(x, y, angle, size, fill){
  const w = size * 0.65;
  const bx = x - Math.cos(angle) * size;
  const by = y - Math.sin(angle) * size;
  const px = Math.cos(angle + Math.PI/2) * (w/2);
  const py = Math.sin(angle + Math.PI/2) * (w/2);

  ctx.save(); ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(bx + px, by + py);
  ctx.lineTo(bx - px, by - py);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

/* ===== coord helpers ===== */
function pointerDisplay(e){ const r = overlay.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
function dispToBase(p){ return { x: p.x/scale, y: p.y/scale }; }
function baseToDisp(p){ return { x: p.x*scale, y: p.y*scale }; }
function drawMark(x,y){ ctx.save(); ctx.fillStyle='rgba(255,255,0,0.9)'; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1.1; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }
function resetCalcs(){ metersPerBasePx=null; tempPtsBase=[]; updateScaleStatus(); const dpr=window.devicePixelRatio||1; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,overlay.width,overlay.height); ctx.setTransform(dpr,0,0,dpr,0,0); sectors225=[]; measures=[]; measureTemp=null; anchorBase=null; showCircle=false; activeProbeIndex=-1; mode=null; renderSectorList(); renderMeasureList(); }

/* ===== raios ===== */
function radiusPxDisp(){ const rBase=(FIXED_RADIUS_KM*1000)/(metersPerBasePx||1); return rBase*scale; }

/* ===== init ===== */
adjustLogScroll();
renderSectorList();
renderMeasureList();
</script>
</body>
</html>
